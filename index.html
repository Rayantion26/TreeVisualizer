<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tree Visualizer | Sync Drawing</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700;800&family=Roboto:wght@400;500&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #f8fafc;
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-main: #334155;
            --accent: #6366f1;
            --input-bg: #ffffff;
            --node-bg: #ffffff;
            --node-border: #6366f1;
            --node-text: #334155;
            --line-color: #94a3b8; 
            --grid-color: rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --anim-left: #f97316;
            --anim-right: #3b82f6;
            --found-color: #22c55e;
        }

        [data-theme="dark"] {
            --bg-color: #020617; 
            --glass-bg: rgba(15, 23, 42, 0.9);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #f8fafc;
            --accent: #818cf8; 
            --input-bg: rgba(30, 41, 59, 0.7);
            --node-bg: #0f172a; 
            --node-border: #a5b4fc; 
            --node-text: #ffffff;
            --line-color: #475569;
            --grid-color: rgba(255, 255, 255, 0.03);
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            --anim-left: #fb923c;
            --anim-right: #60a5fa;
        }

        * { box-sizing: border-box; }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0; padding: 0;
            height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
            user-select: none; /* Prevent text selection while dragging */
        }

        body::before {
            content: ""; position: absolute; inset: 0;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
        }

        /* --- UI LAYERS --- */
        .ui-layer {
            position: relative; width: 100%;
            display: flex; justify-content: center;
            padding: 15px 15px 0 15px;
            z-index: 10;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 16px; padding: 15px 20px;
            box-shadow: var(--shadow);
            width: 100%; max-width: 600px;
            display: flex; flex-direction: column; align-items: center; gap: 12px;
            height: auto; transition: height 0.1s ease; 
        }

        /* --- VERTICAL TOOLBAR --- */
        .toolbar-layer {
            position: absolute; right: 20px; top: 20px; z-index: 30;
            display: flex; flex-direction: column; gap: 10px;
        }

        .draw-tools {
            background: var(--glass-bg); backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border); border-radius: 12px;
            padding: 12px 8px; box-shadow: var(--shadow);
            display: flex; flex-direction: column; align-items: center;
            gap: 8px; width: 50px;
        }

        .tool-btn {
            background: transparent; border: none; color: var(--text-main);
            font-size: 1.2rem; cursor: pointer; padding: 6px;
            border-radius: 6px; transition: 0.2s; 
            width: 36px; height: 36px;
            display: flex; align-items: center; justify-content: center;
        }
        .tool-btn:hover { background: rgba(0,0,0,0.05); }
        .tool-btn.active { background: var(--accent); color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        
        .separator { width: 80%; height: 1px; background: var(--line-color); margin: 2px 0; opacity: 0.5; }

        input[type="color"] {
            -webkit-appearance: none; border: none; width: 28px; height: 28px;
            border-radius: 50%; padding: 0; overflow: hidden; cursor: pointer; background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; border: 2px solid var(--glass-border); }

        input[type=range] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical;
            width: 8px; height: 60px; padding: 0 5px; cursor: ns-resize;
        }

        /* --- CONTROLS --- */
        .row-top { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 10px; }
        .header-left { display: flex; align-items: center; gap: 8px; }
        
        /* NEW HOME BUTTON STYLE */
        .home-btn {
            display: flex; align-items: center; justify-content: center;
            text-decoration: none; font-size: 1.2rem; margin-right: 4px;
            width: 32px; height: 32px; border-radius: 8px;
            background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
            transition: all 0.2s;
        }
        .home-btn:hover { background: var(--accent); transform: scale(1.1); border-color: transparent; }

        h1 { margin: 0; font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 1.1rem; background: linear-gradient(135deg, #818cf8 0%, #c084fc 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; white-space: nowrap; }
        
        .theme-toggle { background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); color: var(--text-main); padding: 5px 10px; border-radius: 8px; cursor: pointer; font-size: 0.75rem; font-weight: 600; white-space: nowrap; }
        .mode-switch { display: flex; background: var(--input-bg); border: 1px solid var(--glass-border); border-radius: 8px; overflow: hidden; cursor: pointer; height: 32px; min-width: 120px; }
        .mode-option { flex: 1; padding: 0 5px; text-align: center; font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 0.75rem; transition: all 0.2s; color: var(--text-main); background: transparent; border: none; opacity: 0.5; white-space: nowrap; }
        .mode-option:hover { background: rgba(0,0,0,0.05); opacity: 1; }
        .mode-option.active { background: var(--accent); color: white; opacity: 1; }

        .input-row { display: flex; gap: 8px; align-items: flex-start; width: 100%; justify-content: center; }
        input[type="text"], textarea { border-radius: 8px; border: 1px solid var(--glass-border); background: var(--input-bg); color: var(--text-main); outline: none; font-family: 'Roboto', sans-serif; font-size: 0.9rem; transition: all 0.1s; text-transform: uppercase; }
        input:focus, textarea:focus { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(129, 140, 248, 0.2); }

        #node-input { width: 160px; text-align: center; padding: 8px 12px; min-height: 36px; height: 36px; resize: none; overflow: hidden; line-height: 1.3; display: block; } 
        #search-input { width: 80px; text-align: center; padding: 0 12px; height: 36px; }

        .btn-action { padding: 0 15px; background: var(--accent); color: white; border: none; border-radius: 8px; font-weight: 700; font-family: 'Montserrat', sans-serif; cursor: pointer; transition: all 0.2s; white-space: nowrap; font-size: 0.85rem; height: 36px; }
        .btn-action:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .btn-action:active { transform: translateY(0); }
        .btn-search { background-color: #10b981; }
        .btn-action:disabled { background-color: var(--line-color); opacity: 0.5; cursor: not-allowed; }

        .path-status { width: 100%; font-family: 'monospace'; font-size: 0.9rem; font-weight: 600; color: var(--text-main); text-align: center; padding-top: 8px; border-top: 1px dashed var(--glass-border); }
        .count-left { color: var(--anim-left); }
        .count-right { color: var(--anim-right); }

        /* --- CANVAS --- */
        #container-wrapper { flex: 1; width: 100%; position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #draw-layer { 
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; 
            z-index: 2; /* Drawing sits on top */
        }

        /* --- CUSTOM CURSOR --- */
        #brush-cursor {
            position: fixed; top: 0; left: 0;
            border: 2px solid var(--text-main); border-radius: 50%;
            pointer-events: none; z-index: 9999;
            transform: translate(-50%, -50%);
            display: none;
            mix-blend-mode: difference;
        }

        .hint-overlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 0.85rem; color: var(--text-main); opacity: 0.6; pointer-events: none; user-select: none; background: var(--glass-bg); padding: 8px 16px; border-radius: 20px; border: 1px solid var(--glass-border); font-weight: 500; z-index: 5; }

        /* SVG Styles */
        .node-group { cursor: pointer; }
        .node-circle { fill: var(--node-bg); stroke: var(--node-border); stroke-width: 2.5px; transition: all 0.4s ease; }
        .node-text { fill: var(--node-text); font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 13px; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        .link { fill: none; stroke: var(--line-color); stroke-width: 2px; stroke-linecap: round; transition: stroke 0.4s ease, stroke-width 0.4s ease; }
        .edge-label-bg { fill: var(--bg-color); stroke: var(--line-color); stroke-width: 1px; }
        .edge-label-text { font-size: 9px; fill: var(--text-main); font-family: 'Roboto Mono', monospace; text-anchor: middle; dominant-baseline: middle; font-weight: bold; }
        .node-circle.visited { stroke: var(--accent); fill: #eef2ff; }
        .node-circle.found { stroke: var(--found-color) !important; fill: #f0fdf4 !important; transform-box: fill-box; transform-origin: center; transform: scale(1.3); }
        [data-theme="dark"] .node-circle.visited { fill: #1e1b4b; }
        [data-theme="dark"] .node-circle.found { fill: #052e16 !important; }
        .link.anim-left { stroke: var(--anim-left) !important; stroke-width: 4px; filter: drop-shadow(0 0 3px var(--anim-left)); }
        .link.anim-right { stroke: var(--anim-right) !important; stroke-width: 4px; filter: drop-shadow(0 0 3px var(--anim-right)); }
        .animate-pop { transform-box: fill-box; transform-origin: center; animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; opacity: 0; }
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

    <div id="brush-cursor"></div>

    <div class="toolbar-layer">
        <div class="draw-tools">
            <button class="tool-btn active" onclick="setTool('hand')" title="Move Tree (Right/Middle Click also works)">‚úã</button>
            <div class="separator"></div>
            <input type="color" id="draw-color" value="#ff0000" title="Color">
            
            <input type="range" id="size-slider" min="2" max="50" value="5" title="Size">

            <button class="tool-btn" onclick="setTool('pen')" title="Pen">‚úé</button>
            <button class="tool-btn" onclick="setTool('marker')" title="Highlighter">üñä</button>
            <button class="tool-btn" onclick="setTool('eraser')" title="Eraser">‚å´</button>
            <div class="separator"></div>
            <button class="tool-btn" onclick="setTool('box')" title="Box">‚¨ú</button>
            <button class="tool-btn" onclick="setTool('circle')" title="Circle">‚óØ</button>
            <button class="tool-btn" onclick="setTool('arrow')" title="Arrow">‚Üó</button>
            <div class="separator"></div>
            <button class="tool-btn" onclick="clearDrawings()" title="Clear All">üóë</button>
        </div>
    </div>

    <div class="ui-layer">
        <div class="glass-panel">
            <div class="row-top">
                <div class="header-left">
                    <a href="https://rayantion.me" class="home-btn" title="Return Home">üè†</a>
                    <h1>Tree Visualizer</h1>
                    <button class="theme-toggle" onclick="toggleTheme()">üåó Theme</button>
                </div>
                <div class="mode-switch">
                    <button id="mode-bst" class="mode-option active" onclick="setMode('BST')">BST</button>
                    <button id="mode-avl" class="mode-option" onclick="setMode('AVL')">AVL</button>
                </div>
            </div>

            <div class="input-row">
                <textarea id="node-input" placeholder="e.g. 10, 20" rows="1">10, 20, 30, 40, 50, 25</textarea>
                <button class="btn-action" onclick="initTree()">Go</button>
            </div>

            <div class="input-row">
                <input type="text" id="search-input" placeholder="#" oninput="handleSearchInput()">
                <button id="btn-search" class="btn-action btn-search" onclick="searchTree()" disabled>Find</button>
            </div>

            <div id="path-display" class="path-status">
                <span id="path-val">Tree Ready</span>
            </div>
        </div>
    </div>

    <div id="container-wrapper">
        <div id="canvas-container">
            <svg id="main-svg" width="100%" height="100%">
                <g id="viewport"></g>
            </svg>
        </div>
        <canvas id="draw-layer"></canvas>
    </div>

    <div class="hint-overlay">Right/Middle Click to Pan ‚Ä¢ Scroll to Zoom ‚Ä¢ Left Click to Draw</div>

    <script>
        function toggleTheme() {
            const html = document.documentElement;
            html.setAttribute('data-theme', html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        }

        let nodeIdCounter = 0; 
        let isAVLMode = false;

        function setMode(mode) {
            isAVLMode = (mode === 'AVL');
            document.getElementById('mode-bst').classList.toggle('active', !isAVLMode);
            document.getElementById('mode-avl').classList.toggle('active', isAVLMode);
            initTree();
        }

        // --- TREE LOGIC ---
        class Node {
            constructor(val) {
                this.id = nodeIdCounter++; this.value = val;
                this.left = null; this.right = null;
                this.height = 1; this.x = 0; this.y = 0;
            }
        }

        class Tree {
            constructor(isAVL) { this.root = null; this.isAVL = isAVL; }
            compare(a, b) {
                const numA = parseFloat(a), numB = parseFloat(b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return String(a).localeCompare(String(b));
            }
            getHeight(N) { return N ? N.height : 0; }
            getBalance(N) { return N ? this.getHeight(N.left) - this.getHeight(N.right) : 0; }
            rightRotate(y) {
                let x = y.left; let T2 = x.right;
                x.right = y; y.left = T2;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                return x;
            }
            leftRotate(x) {
                let y = x.right; let T2 = y.left;
                y.left = x; x.right = T2;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                return y;
            }
            insert(val) { this.root = this.insertNode(this.root, val); }
            insertNode(node, val) {
                if (!node) return new Node(val);
                if (this.compare(val, node.value) < 0) node.left = this.insertNode(node.left, val);
                else node.right = this.insertNode(node.right, val);

                if (!this.isAVL) return node;
                node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
                let balance = this.getBalance(node);
                if (balance > 1 && this.compare(val, node.left.value) < 0) return this.rightRotate(node);
                if (balance < -1 && this.compare(val, node.right.value) >= 0) return this.leftRotate(node);
                if (balance > 1 && this.compare(val, node.left.value) > 0) { node.left = this.leftRotate(node.left); return this.rightRotate(node); }
                if (balance < -1 && this.compare(val, node.right.value) < 0) { node.right = this.rightRotate(node.right); return this.leftRotate(node); }
                return node;
            }
            getSearchData(val) {
                const pathNodes = [];
                let leftCount = 0, rightCount = 0;
                let current = this.root;
                while(current) {
                    pathNodes.push(current);
                    const diff = this.compare(val, current.value);
                    if (diff === 0) return { pathNodes, leftCount, rightCount, found: true }; 
                    if (diff < 0) { current = current.left; leftCount++; } 
                    else { current = current.right; rightCount++; }
                }
                return { pathNodes, leftCount, rightCount, found: false };
            }
        }

        const NODE_R = 18, X_GAP = 30, Y_GAP = 70;   
        let treeInstance = null;
        let viewState = { scale: 1, pX: 0, pY: 0, isDragging: false, startX: 0, startY: 0 };
        const container = document.getElementById('canvas-container');
        const viewport = document.getElementById('viewport');
        const searchBtn = document.getElementById('btn-search');
        const pathDisplay = document.getElementById('path-val');

        function initTree() {
            nodeIdCounter = 0; pathDisplay.innerHTML = ""; 
            const input = document.getElementById('node-input');
            const raw = input.value.split(',').map(s => s.trim().toUpperCase()).filter(s => s !== "");
            if (!raw.length) return;
            const final = raw.map(v => (isNaN(parseFloat(v)) ? v : parseFloat(v)));

            treeInstance = new Tree(isAVLMode);
            final.forEach(n => treeInstance.insert(n));

            viewport.innerHTML = ''; 
            let xCounter = 0;
            const calcPos = (node, depth) => {
                if (!node) return;
                calcPos(node.left, depth + 1);
                node.x = xCounter * X_GAP; node.y = depth * Y_GAP;
                xCounter++;
                calcPos(node.right, depth + 1);
            };

            if (treeInstance.root) {
                calcPos(treeInstance.root, 0);
                drawLinks(treeInstance.root);
                drawNodes(treeInstance.root);
                smartFit((xCounter) * X_GAP, (getMaxDepth(treeInstance.root) + 1) * Y_GAP);
                searchBtn.disabled = false;
            } else {
                searchBtn.disabled = true;
            }
        }

        async function searchTree() {
            if (!treeInstance || !treeInstance.root) return;
            let inputVal = document.getElementById('search-input').value.trim().toUpperCase();
            if (!inputVal) return;
            let searchVal = isNaN(parseFloat(inputVal)) ? inputVal : parseFloat(inputVal);

            resetHighlights();
            pathDisplay.innerHTML = "Searching...";

            const { pathNodes, leftCount, rightCount, found } = treeInstance.getSearchData(searchVal);

            for (let i = 0; i < pathNodes.length; i++) {
                const node = pathNodes[i];
                const svgNode = document.getElementById(`circle-${node.id}`);
                
                if (svgNode) {
                    if (i === pathNodes.length - 1 && found) svgNode.classList.add('found');
                    else svgNode.classList.add('visited');
                }

                if (i < pathNodes.length - 1) {
                    const nextNode = pathNodes[i+1];
                    const linkId = `link-${node.id}-${nextNode.id}`;
                    const svgLink = document.getElementById(linkId);
                    if (svgLink) {
                        if (treeInstance.compare(nextNode.value, node.value) < 0) svgLink.classList.add('anim-left');
                        else svgLink.classList.add('anim-right');
                    }
                }
                await new Promise(r => setTimeout(r, 400));
            }
            if (found) pathDisplay.innerHTML = `Found! Moves: <span class="count-left">${leftCount} Left</span>, <span class="count-right">${rightCount} Right</span>`;
            else pathDisplay.innerHTML = `Not Found. (Moves: ${leftCount} L, ${rightCount} R)`;
        }

        function handleSearchInput() {
            document.getElementById('search-input').value = document.getElementById('search-input').value.toUpperCase();
            pathDisplay.innerHTML = "";
            resetHighlights();
        }

        function resetHighlights() {
            document.querySelectorAll('.node-circle').forEach(el => el.classList.remove('visited', 'found'));
            document.querySelectorAll('.link').forEach(el => el.classList.remove('anim-left', 'anim-right'));
        }

        function getMaxDepth(node) {
            if (!node) return 0;
            return 1 + Math.max(getMaxDepth(node.left), getMaxDepth(node.right));
        }

        function drawLinks(node) {
            if (!node) return;
            if (node.left) { createLine(node.x, node.y, node.left.x, node.left.y, node.id, node.left.id, "L"); drawLinks(node.left); }
            if (node.right) { createLine(node.x, node.y, node.right.x, node.right.y, node.id, node.right.id, "R"); drawLinks(node.right); }
        }

        function createLine(x1, y1, x2, y2, startId, endId, label) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1); line.setAttribute("y1", y1);
            line.setAttribute("x2", x2); line.setAttribute("y2", y2);
            line.setAttribute("class", "link");
            line.setAttribute("id", `link-${startId}-${endId}`);
            viewport.appendChild(line);

            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g"); g.style.pointerEvents = "none";
            const bg = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            bg.setAttribute("cx", midX); bg.setAttribute("cy", midY); bg.setAttribute("r", 6); bg.setAttribute("class", "edge-label-bg");
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", midX); text.setAttribute("y", midY); text.setAttribute("dy", "0.5px"); text.setAttribute("class", "edge-label-text");
            text.textContent = label;
            g.appendChild(bg); g.appendChild(text); viewport.appendChild(g);
        }

        function drawNodes(node) {
            if (!node) return;
            createNode(node.x, node.y, node.value, node.id);
            drawNodes(node.left); drawNodes(node.right);
        }

        function createNode(x, y, val, id) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("class", "node-group animate-pop");
            g.style.animationDelay = `${y/Y_GAP * 50}ms`;
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x); circle.setAttribute("cy", y); circle.setAttribute("r", NODE_R);
            circle.setAttribute("class", "node-circle"); circle.setAttribute("id", `circle-${id}`);
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", x); text.setAttribute("y", y); text.setAttribute("class", "node-text"); text.textContent = val;
            g.appendChild(circle); g.appendChild(text); viewport.appendChild(g);
        }

        function smartFit(treeW, treeH) {
            const w = container.clientWidth, h = container.clientHeight;
            const padding = 60; 
            const scale = Math.min((w - padding) / Math.max(treeW, 100), (h - padding) / Math.max(treeH, 100), 1.2);
            viewState.scale = Math.max(scale, 0.2);
            viewState.pX = (w - treeW * viewState.scale) / 2;
            viewState.pY = (h - treeH * viewState.scale) / 2;
            viewState.pY = Math.max(viewState.pY, 40);
            updateTransform();
        }

        function updateTransform() { 
            // Update SVG
            viewport.setAttribute("transform", `translate(${viewState.pX}, ${viewState.pY}) scale(${viewState.scale})`); 
            // Update Drawings (Redraw everything in new coordinates)
            renderDrawings();
        }
        
        // --- EVENT LISTENERS (PAN/ZOOM) ---
        // Prevent default context menu for right click panning
        window.oncontextmenu = (e) => e.preventDefault();

        const wrapper = document.getElementById('container-wrapper');

        // ZOOM (Scroll)
        wrapper.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = wrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // World coord before zoom
            const worldX = (mouseX - viewState.pX) / viewState.scale;
            const worldY = (mouseY - viewState.pY) / viewState.scale;

            const zoomSensitivity = 0.001;
            let newScale = viewState.scale + (e.deltaY * -zoomSensitivity * viewState.scale);
            newScale = Math.max(0.05, Math.min(newScale, 10));

            viewState.pX = mouseX - worldX * newScale;
            viewState.pY = mouseY - worldY * newScale;
            viewState.scale = newScale;
            updateTransform();
        }, { passive: false });

        // PANNING LOGIC
        wrapper.addEventListener('mousedown', e => {
            // Button 0 = Left, 1 = Middle, 2 = Right
            const isRightOrMiddle = e.button === 1 || e.button === 2;
            const isHandTool = currentTool === 'hand' && e.button === 0;

            if (isRightOrMiddle || isHandTool) {
                viewState.isDragging = true;
                viewState.startX = e.clientX - viewState.pX;
                viewState.startY = e.clientY - viewState.pY;
                wrapper.style.cursor = "grabbing";
            }
        });

        window.addEventListener('mousemove', e => {
            if (viewState.isDragging) {
                e.preventDefault();
                viewState.pX = e.clientX - viewState.startX;
                viewState.pY = e.clientY - viewState.startY;
                updateTransform();
            }
        });

        window.addEventListener('mouseup', () => {
            viewState.isDragging = false;
            // Restore cursor based on tool
            if(currentTool === 'hand') wrapper.style.cursor = "grab";
            else {
                wrapper.style.cursor = "default";
            }
        });

        const inputNode = document.getElementById('node-input');
        function autoResize() {
            this.style.height = '36px'; 
            this.style.height = this.scrollHeight + 'px'; 
        }
        inputNode.addEventListener('input', autoResize);
        
        inputNode.addEventListener('keypress', function(e) {
            if(e.key === "Enter") {
                e.preventDefault(); 
                initTree();
            }
        });

        document.getElementById('search-input').addEventListener('keypress', (e) => { if(e.key === "Enter" && !searchBtn.disabled) searchTree(); });
        
        // --- ADVANCED DRAWING ENGINE (VECTOR STATE) ---
        const drawCanvas = document.getElementById('draw-layer');
        const ctx = drawCanvas.getContext('2d');
        const colorPicker = document.getElementById('draw-color');
        const sizeSlider = document.getElementById('size-slider');
        const cursorDiv = document.getElementById('brush-cursor');
        
        // State
        let drawings = []; // Array of { type: 'path'|'box'|..., color, size, points: [], ... }
        let currentStroke = null;
        let isDrawing = false;
        let currentTool = 'hand'; 

        function resizeCanvas() {
            drawCanvas.width = wrapper.clientWidth;
            drawCanvas.height = wrapper.clientHeight;
            renderDrawings();
        }
        window.addEventListener('resize', resizeCanvas);

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.tool-btn').classList.add('active');
            
            // Cursor Logic
            if (tool === 'hand') {
                drawCanvas.style.pointerEvents = 'none'; // Let events pass to wrapper for pan
                cursorDiv.style.display = 'none';
                wrapper.style.cursor = 'grab';
            } else {
                drawCanvas.style.pointerEvents = 'auto'; // Capture for drawing
                wrapper.style.cursor = 'default';
                
                if(['pen','marker','eraser'].includes(tool)) {
                    cursorDiv.style.display = 'block';
                    drawCanvas.style.cursor = 'none';
                } else {
                    cursorDiv.style.display = 'none';
                    drawCanvas.style.cursor = 'crosshair';
                }
            }
        }

        function clearDrawings() {
            drawings = [];
            renderDrawings();
        }

        // --- DRAWING RENDERER ---
        function renderDrawings() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            
            ctx.save();
            // Apply Global Transform (Zoom/Pan)
            ctx.translate(viewState.pX, viewState.pY);
            ctx.scale(viewState.scale, viewState.scale);

            // Helper to draw a single item
            const drawItem = (d) => {
                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (d.type === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = d.size;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = d.color;
                    ctx.lineWidth = d.size;
                    ctx.globalAlpha = d.type === 'marker' ? 0.15 : 1.0;
                }

                if (['pen','marker','eraser'].includes(d.type)) {
                    if(d.points.length < 2) return;
                    ctx.moveTo(d.points[0].x, d.points[0].y);
                    for(let i=1; i<d.points.length; i++) {
                        ctx.lineTo(d.points[i].x, d.points[i].y);
                    }
                    ctx.stroke();
                }
                else if (d.type === 'box') {
                    ctx.rect(d.x, d.y, d.w, d.h);
                    ctx.stroke();
                }
                else if (d.type === 'circle') {
                    ctx.ellipse(d.cx, d.cy, d.rx, d.ry, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                else if (d.type === 'arrow') {
                    drawArrowInContext(ctx, d.x1, d.y1, d.x2, d.y2);
                }
            };

            drawings.forEach(drawItem);
            
            // Draw current stroke being drawn (Preview)
            if(currentStroke) drawItem(currentStroke);

            ctx.restore();
        }

        function drawArrowInContext(ctx, x1, y1, x2, y2) {
            const headlen = 15; 
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        // --- DRAWING INPUT HANDLERS ---
        // Convert screen coord to world coord
        function toWorld(x, y) {
            return {
                x: (x - viewState.pX) / viewState.scale,
                y: (y - viewState.pY) / viewState.scale
            };
        }

        drawCanvas.addEventListener('mousedown', (e) => {
            // Only Left Click (0) triggers drawing
            if(e.button !== 0 || currentTool === 'hand') return;

            isDrawing = true;
            const wPos = toWorld(e.offsetX, e.offsetY);
            let size = parseInt(sizeSlider.value);
            if(currentTool === 'marker') size = 25;

            // Init Stroke Data
            if(['pen','marker','eraser'].includes(currentTool)) {
                currentStroke = {
                    type: currentTool,
                    color: colorPicker.value,
                    size: size,
                    points: [{x: wPos.x, y: wPos.y}]
                };
            } else {
                // Shapes
                currentStroke = {
                    type: currentTool,
                    color: colorPicker.value,
                    size: 3,
                    startX: wPos.x, startY: wPos.y, // Store raw start
                    // Temp placeholders
                    x: wPos.x, y: wPos.y, w:0, h:0 
                };
            }
            renderDrawings();
        });

        window.addEventListener('mousemove', (e) => {
            // Cursor Update
            if(cursorDiv.style.display !== 'none') {
                cursorDiv.style.left = e.clientX + 'px';
                cursorDiv.style.top = e.clientY + 'px';
                let size = parseInt(sizeSlider.value);
                if(currentTool === 'marker') size = 25;
                // Scale cursor visual based on zoom? 
                // Actually, brush size is usually defined in screen pixels or world pixels?
                // For a consistent "feel", brush usually scales with zoom in these apps.
                // So the visual cursor should match the rendered line width * scale.
                cursorDiv.style.width = (size * viewState.scale) + 'px';
                cursorDiv.style.height = (size * viewState.scale) + 'px';
            }

            if (!isDrawing || !currentStroke) return;

            // Get mouse position inside canvas
            const rect = drawCanvas.getBoundingClientRect();
            const wPos = toWorld(e.clientX - rect.left, e.clientY - rect.top);

            if(['pen','marker','eraser'].includes(currentTool)) {
                currentStroke.points.push({x: wPos.x, y: wPos.y});
            } 
            else if (currentTool === 'box') {
                currentStroke.x = currentStroke.startX;
                currentStroke.y = currentStroke.startY;
                currentStroke.w = wPos.x - currentStroke.startX;
                currentStroke.h = wPos.y - currentStroke.startY;
            }
            else if (currentTool === 'circle') {
                // Top-Left Logic
                let startX = currentStroke.startX;
                let startY = currentStroke.startY;
                let endX = wPos.x;
                let endY = wPos.y;
                
                currentStroke.cx = startX + (endX - startX)/2;
                currentStroke.cy = startY + (endY - startY)/2;
                currentStroke.rx = Math.abs((endX - startX)/2);
                currentStroke.ry = Math.abs((endY - startY)/2);
            }
            else if (currentTool === 'arrow') {
                currentStroke.x1 = currentStroke.startX;
                currentStroke.y1 = currentStroke.startY;
                currentStroke.x2 = wPos.x;
                currentStroke.y2 = wPos.y;
            }
            renderDrawings();
        });

        window.addEventListener('mouseup', () => {
            if(isDrawing && currentStroke) {
                drawings.push(currentStroke);
                currentStroke = null;
                isDrawing = false;
                renderDrawings();
            }
        });

        window.onload = () => {
            autoResize.call(inputNode);
            resizeCanvas();
            setTimeout(initTree, 50);
        };
    </script>
</body>
</html>
