<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tree Visualizer | Final Fixed</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com/css2">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600;700;800&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        :root {
            --bg-color: #f8fafc;
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(0, 0, 0, 0.1);
            --text-main: #334155;
            --accent: #6366f1;
            --input-bg: #ffffff;
            --node-bg: #ffffff;
            --node-border: #6366f1;
            --node-text: #334155;
            --line-color: #94a3b8; 
            --grid-color: rgba(0, 0, 0, 0.05);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --anim-left: #f97316;
            --anim-right: #3b82f6;
            --found-color: #22c55e;
            --icon-color: #475569;
            --danger-color: #ef4444;
        }

        [data-theme="dark"] {
            --bg-color: #020617; 
            --glass-bg: rgba(15, 23, 42, 0.9);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #f8fafc;
            --accent: #818cf8; 
            --input-bg: rgba(30, 41, 59, 0.7);
            --node-bg: #0f172a; 
            --node-border: #a5b4fc; 
            --node-text: #ffffff;
            --line-color: #475569;
            --grid-color: rgba(255, 255, 255, 0.03);
            --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            --anim-left: #fb923c;
            --anim-right: #60a5fa;
            --icon-color: #cbd5e1;
            --danger-color: #f87171;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0; padding: 0;
            height: 100vh; width: 100vw;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }

        body::before {
            content: ""; position: absolute; inset: 0;
            background-image: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
            pointer-events: none; 
        }

        #container-wrapper { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 1; overflow: hidden; 
            background: var(--bg-color); 
        }
        #canvas-container { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #draw-layer { 
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; 
            z-index: 2; pointer-events: auto; touch-action: none; 
        }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%;
            display: flex; justify-content: center;
            padding: 15px;
            z-index: 10;
            pointer-events: none;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 16px; padding: 15px 20px;
            box-shadow: var(--shadow);
            width: 100%; max-width: 650px;
            display: flex; flex-direction: column; align-items: center; gap: 12px;
            pointer-events: auto;
        }

        /* --- TOOLBAR --- */
        .toolbar-layer {
            position: absolute; right: 20px; top: 20px; z-index: 30;
            pointer-events: none; 
        }
        .toolbar-layer.pinned-mobile {
            top: 50%; right: 10px; left: auto; bottom: auto;
            transform: translateY(-50%);
        }

        .draw-tools {
            background: var(--glass-bg); backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border); border-radius: 12px;
            padding: 8px; box-shadow: var(--shadow);
            display: flex; flex-direction: column; align-items: center;
            gap: 10px; width: 56px; 
            pointer-events: auto; 
            position: relative; 
        }

        .drag-handle {
            width: 100%; height: 30px; cursor: grab;
            display: flex; justify-content: center; align-items: center;
            opacity: 0.5; touch-action: none;
        }
        .drag-handle:active { cursor: grabbing; }
        .drag-dots {
            width: 20px; height: 6px;
            border-top: 2px dotted var(--icon-color);
            border-bottom: 2px dotted var(--icon-color);
        }

        .tool-btn {
            background: transparent; border: none; color: var(--icon-color);
            cursor: pointer; padding: 6px;
            border-radius: 6px; transition: 0.2s; 
            width: 38px; height: 38px;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
        .tool-btn svg { width: 22px; height: 22px; fill: currentColor; }
        .tool-btn:hover { background: rgba(0,0,0,0.05); color: var(--accent); }
        .tool-btn.active { background: var(--accent); color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .tool-btn.active svg { fill: white; }
        
        .separator { width: 70%; height: 1px; background: var(--line-color); opacity: 0.3; margin: 2px 0; flex-shrink: 0;}

        input[type="color"] {
            -webkit-appearance: none; border: none; width: 32px; height: 32px;
            border-radius: 50%; padding: 0; overflow: hidden; cursor: pointer; background: none;
            transition: transform 0.2s; flex-shrink: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; border: 2px solid var(--glass-border); }

        .size-group { display: flex; flex-direction: column; align-items: center; gap: 4px; width: 100%; }

        .size-dragger {
            width: 38px; height: 34px;
            background: rgba(0,0,0,0.03);
            border: 1px solid var(--glass-border); border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: ew-resize; user-select: none; touch-action: none;
            transition: all 0.2s;
        }
        .size-dragger:hover, .size-dragger.dragging { background: var(--accent); border-color: transparent; }
        .size-dragger:hover span, .size-dragger.dragging span { color: white; }
        .size-dragger span { font-size: 8px; font-weight: 700; color: var(--text-main); line-height: 1; pointer-events: none; }
        .size-dragger .val { font-size: 11px; margin-top: 1px; }

        .mini-slider {
            -webkit-appearance: none; width: 40px; height: 14px; border-radius: 2px;
            background: transparent; outline: none; cursor: pointer; position: relative;
        }
        .mini-slider::after {
            content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 2px; 
            background: var(--glass-border); transform: translateY(-50%); z-index: -1;
        }
        .mini-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%;
            background: var(--accent); cursor: pointer; border: 2px solid var(--bg-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .row-top { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; width: 100%; gap: 10px; }
        .header-left { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        
        .home-btn {
            display: flex; align-items: center; justify-content: center;
            text-decoration: none; font-size: 1.2rem; margin-right: 4px;
            width: 32px; height: 32px; border-radius: 8px;
            background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border);
            transition: all 0.2s;
        }
        
        h1 { margin: 0; font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 1.1rem; background: linear-gradient(135deg, #818cf8 0%, #c084fc 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; white-space: nowrap; }
        
        .theme-toggle { background: rgba(255,255,255,0.05); border: 1px solid var(--glass-border); color: var(--text-main); padding: 5px 10px; border-radius: 8px; cursor: pointer; font-size: 0.75rem; font-weight: 600; white-space: nowrap; }
        
        .mode-switch { display: flex; background: var(--input-bg); border: 1px solid var(--glass-border); border-radius: 8px; overflow: hidden; cursor: pointer; height: 32px; min-width: 150px; flex-shrink: 0; }
        .mode-option { flex: 1; padding: 0 8px; text-align: center; font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 0.75rem; transition: all 0.2s; color: var(--text-main); background: transparent; border: none; opacity: 0.5; white-space: nowrap; }
        .mode-option:hover { background: rgba(0,0,0,0.05); opacity: 1; }
        .mode-option.active { background: var(--accent); color: white; opacity: 1; }

        .input-row { display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-start; width: 100%; justify-content: center; }
        input[type="text"], textarea, input[type="number"] { border-radius: 8px; border: 1px solid var(--glass-border); background: var(--input-bg); color: var(--text-main); outline: none; font-family: 'Roboto', sans-serif; font-size: 0.9rem; transition: all 0.1s; text-transform: uppercase; }
        
        #node-input { 
            flex-grow: 1; width: auto; min-width: 150px;
            text-align: center; padding: 8px 12px; 
            min-height: 36px; height: 36px; 
            resize: none; overflow: hidden; line-height: 1.3; display: block; 
        } 
        #search-input { width: 100px; text-align: center; padding: 0 12px; height: 36px; }
        
        #order-input-container { display: none; align-items: center; gap: 5px; font-size: 0.8rem; font-weight: 700; color: var(--text-main); }
        #order-input { width: 50px; text-align: center; height: 36px; padding: 0 5px; }

        .btn-action { padding: 0 15px; background: var(--accent); color: white; border: none; border-radius: 8px; font-weight: 700; font-family: 'Montserrat', sans-serif; cursor: pointer; transition: all 0.2s; white-space: nowrap; font-size: 0.85rem; height: 36px; }
        .btn-search { background-color: #10b981; }
        .btn-delete { background-color: var(--danger-color); }
        .btn-action:disabled { background-color: var(--line-color); opacity: 0.5; cursor: not-allowed; }

        .path-status { 
            width: 100%; font-family: 'monospace'; font-size: 0.9rem; font-weight: 600; 
            color: var(--text-main); text-align: center; padding-top: 8px; 
            border-top: none;
        }
        .count-left { color: var(--anim-left); }
        .count-right { color: var(--anim-right); }

        #brush-cursor {
            position: fixed; top: 0; left: 0;
            border: 2px solid var(--text-main); border-radius: 50%;
            pointer-events: none; z-index: 9999;
            transform: translate(-50%, -50%);
            display: none;
            mix-blend-mode: difference;
        }

        .hint-overlay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 0.85rem; color: var(--text-main); opacity: 0.6; pointer-events: none; user-select: none; background: var(--glass-bg); padding: 8px 16px; border-radius: 20px; border: 1px solid var(--glass-border); font-weight: 500; z-index: 5; text-align: center; width: 90%; }

        /* --- PREVIEW MODAL --- */
        #export-modal {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 1000;
            justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: var(--bg-color);
            padding: 20px; border-radius: 16px;
            max-width: 90%; max-height: 90%;
            display: flex; flex-direction: column; gap: 15px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow);
            width: 500px;
        }
        .modal-header { font-family: 'Montserrat', sans-serif; font-weight: 800; font-size: 1.2rem; }
        .preview-img { width: 100%; height: auto; border-radius: 8px; border: 1px solid var(--glass-border); max-height: 50vh; object-fit: contain; background: var(--bg-color); }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }
        .btn-secondary { background: var(--line-color); color: white; }

        /* SVG Styles */
        .node-group { cursor: pointer; }
        .node-circle { fill: var(--node-bg); stroke: var(--node-border); stroke-width: 2.5px; transition: all 0.4s ease; }
        .node-text { fill: var(--node-text); font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 13px; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        .node-circle.red { fill: #ef4444 !important; stroke: #b91c1c !important; }
        .node-circle.black { fill: #171717 !important; stroke: #404040 !important; }
        .node-group.rbt-mode .node-text { fill: #ffffff !important; }
        .link { fill: none; stroke: var(--line-color); stroke-width: 2px; stroke-linecap: round; transition: stroke 0.4s ease, stroke-width 0.4s ease; }
        .edge-label-bg { fill: var(--bg-color); stroke: var(--line-color); stroke-width: 1px; }
        .edge-label-text { font-size: 9px; fill: var(--text-main); font-family: 'Roboto Mono', monospace; text-anchor: middle; dominant-baseline: middle; font-weight: bold; }
        .node-circle.visited { stroke: var(--accent); fill: #eef2ff; }
        .node-circle.found { stroke: var(--found-color) !important; fill: #f0fdf4 !important; transform-box: fill-box; transform-origin: center; transform: scale(1.3); }
        [data-theme="dark"] .node-circle.visited { fill: #1e1b4b; }
        [data-theme="dark"] .node-circle.found { fill: #052e16 !important; }
        .node-circle.red.found { stroke: #fbbf24 !important; stroke-width: 4px; }
        .node-circle.black.found { stroke: #22c55e !important; stroke-width: 4px; }
        .link.anim-left { stroke: var(--anim-left) !important; stroke-width: 4px; filter: drop-shadow(0 0 3px var(--anim-left)); }
        .link.anim-right { stroke: var(--anim-right) !important; stroke-width: 4px; filter: drop-shadow(0 0 3px var(--anim-right)); }
        .animate-pop { transform-box: fill-box; transform-origin: center; animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; opacity: 0; }
        @keyframes popIn { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }

        /* B-TREE SPECIFIC STYLES */
        .btree-node { fill: var(--node-bg); stroke: var(--node-border); stroke-width: 2px; }
        .btree-text { fill: var(--node-text); font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 12px; text-anchor: middle; dominant-baseline: central; }
        .btree-separator { stroke: var(--line-color); stroke-width: 1px; }

        @media (max-width: 768px) {
            .glass-panel { padding: 10px; width: 95%; margin-top: 10px; gap: 8px; }
            h1 { font-size: 1rem; }
            .row-top { gap: 8px; }
            .header-left { flex: 1; min-width: 150px; }
            .mode-switch { flex: 1; min-width: 140px; }
            .input-row { gap: 6px; }
            .btn-action { padding: 0 10px; font-size: 0.8rem; height: 36px; }
            #node-input { font-size: 0.85rem; }
            .draw-tools { width: 44px; gap: 6px; padding: 6px; }
            .tool-btn { width: 30px; height: 30px; padding: 5px; }
            .size-dragger { width: 30px; height: 30px; }
            .mini-slider { width: 30px; }
            .drag-handle { height: 24px; }
            .hint-overlay { display: none; }
        }
    </style>
</head>
<body>

    <div id="export-modal">
        <div class="modal-content">
            <div class="modal-header">Export Preview</div>
            <img id="preview-img" class="preview-img" alt="Tree Preview">
            <div class="modal-actions">
                <button class="btn-action btn-secondary" onclick="closeExport()">Back</button>
                <button class="btn-action" onclick="downloadPDF()">Download PDF</button>
                <button class="btn-action" onclick="downloadPNG()">Download PNG</button>
            </div>
        </div>
    </div>

    <div id="brush-cursor"></div>

    <div class="toolbar-layer pinned-mobile">
        <div class="draw-tools" id="toolbar">
            <div class="drag-handle" id="toolbar-drag">
                <div class="drag-dots"></div>
            </div>

            <button class="tool-btn" onclick="openExport()" title="Camera / Export">
                <svg viewBox="0 0 24 24"><path d="M20 4h-3.17L15 2H9L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V6h4.05l1.83-2h4.24l1.83 2H20v12zM12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0 8c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z"/></svg>
            </button>

            <div class="separator"></div>

            <button class="tool-btn active" onclick="setTool('hand')" title="Pan">
                <svg viewBox="0 0 24 24"><path d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16l.41.25.1.05v-5.2c0-1.1.9-2 2-2s2 .9 2 2v2.5h1v-4c0-1.1.9-2 2-2s2 .9 2 2v4h1v-3.5c0-1.1.9-2 2-2s2 .9 2 2v3.5h1v-2c0-1.1.9-2 2-2s2 .9 2 2v2z"/></svg>
            </button>
            
            <div class="separator"></div>
            
            <input type="color" id="draw-color" value="#ff0000" title="Color">
            
            <div class="size-group">
                <div class="size-dragger" id="size-dragger" title="Drag to Resize">
                    <span>SIZE</span>
                    <span class="val" id="size-val">5</span>
                </div>
                <input type="range" id="mini-slider" class="mini-slider" min="1" max="100" value="5" title="Size Slider">
            </div>

            <div class="separator"></div>

            <button class="tool-btn" onclick="setTool('pen')" title="Pen">
                <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
            </button>
            <button class="tool-btn" onclick="setTool('marker')" title="Highlighter">
                <svg viewBox="0 0 24 24"><path d="M18.5 1.15c-.53 0-1.04.19-1.43.58l-10.49 10.49c-.39.39-.58.9-.58 1.43v5.85h5.85c.53 0 1.04-.19 1.43-.58l10.49-10.49c.76-.76.76-2.03 0-2.79l-4.47-4.49c-.2-.2-.51-.2-.71 0zm-12 15.35h-3v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-3.5z"/></svg>
            </button>
            <button class="tool-btn" onclick="setTool('eraser')" title="Eraser">
                <svg viewBox="0 0 24 24"><path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0zM4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l1.41-1.41-6.36-6.36-1.42 1.41c-.78.79-.78 2.05 0 2.83z"/></svg>
            </button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="setTool('box')" title="Rectangle">
                <svg viewBox="0 0 24 24"><path d="M3 3h18v18H3V3m2 2v14h14V5H5z"/></svg>
            </button>
            <button class="tool-btn" onclick="setTool('circle')" title="Ellipse">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
            </button>
            <button class="tool-btn" onclick="setTool('arrow')" title="Arrow">
                <svg viewBox="0 0 24 24"><path d="M16.01 11H4v2h12.01v3L20 12l-3.99-4z"/></svg>
            </button>
            
            <div class="separator"></div>
            
            <button class="tool-btn" onclick="undo()" title="Undo">
                <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
            </button>
            <button class="tool-btn" onclick="redo()" title="Redo">
                <svg viewBox="0 0 24 24"><path d="M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/></svg>
            </button>
            <button class="tool-btn" onclick="clearDrawings()" title="Clear">
                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
            </button>
        </div>
    </div>

    <div class="ui-layer">
        <div class="glass-panel">
            <div class="row-top">
                <div class="header-left">
                    <a href="/" class="home-btn" title="Return Home">üè†</a>
                    <h1>Tree Visualizer</h1>
                    <button class="theme-toggle" onclick="toggleTheme()">üåó Theme</button>
                </div>
                <div class="mode-switch">
                    <button id="mode-bst" class="mode-option active" onclick="setMode('BST')">BST</button>
                    <button id="mode-avl" class="mode-option" onclick="setMode('AVL')">AVL</button>
                    <button id="mode-rbt" class="mode-option" onclick="setMode('RBT')">RBT</button>
                    <button id="mode-btree" class="mode-option" onclick="setMode('BTREE')">B-Tree</button>
                </div>
            </div>

            <div class="input-row">
                <textarea id="node-input" placeholder="e.g. 10, 20" rows="1">10, 20, 30, 40, 50, 25</textarea>
                <div id="order-input-container">
                    <span>Order:</span>
                    <input type="number" id="order-input" value="3" min="3" max="10">
                </div>
                <button class="btn-action" onclick="initTree()">Go</button>
            </div>

            <div class="input-row">
                <input type="text" id="search-input" placeholder="# to Find/Del" oninput="handleSearchInput()">
                <button id="btn-search" class="btn-action btn-search" onclick="searchTree()" disabled>Find</button>
                <button id="btn-delete" class="btn-action btn-delete" onclick="deleteNode()" disabled>Delete</button>
            </div>

            <div id="path-display" class="path-status">
                <span id="path-val">Tree Ready</span>
            </div>
        </div>
    </div>

    <div id="container-wrapper">
        <div id="canvas-container">
            <svg id="main-svg" width="100%" height="100%">
                <g id="viewport"></g>
            </svg>
        </div>
        <canvas id="draw-layer"></canvas>
    </div>

    <div class="hint-overlay">Right/Middle Click to Pan ‚Ä¢ Scroll to Zoom ‚Ä¢ Left Click to Draw</div>

    <script>
        // --- EXPORT LOGIC ---
        let currentCanvasDataURL = null;

        function openExport() {
            document.querySelector('.ui-layer').style.display = 'none';
            document.querySelector('.toolbar-layer').style.display = 'none';
            document.querySelector('.hint-overlay').style.display = 'none';
            document.getElementById('brush-cursor').style.display = 'none';

            html2canvas(document.getElementById('container-wrapper'), {
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--bg-color').trim(),
                scale: 2
            }).then(canvas => {
                currentCanvasDataURL = canvas.toDataURL('image/png');
                document.getElementById('preview-img').src = currentCanvasDataURL;
                document.getElementById('export-modal').style.display = 'flex';

                document.querySelector('.ui-layer').style.display = 'flex';
                document.querySelector('.toolbar-layer').style.display = 'block';
                document.querySelector('.hint-overlay').style.display = 'block'; 
                if(['pen','marker','eraser'].includes(currentTool)) document.getElementById('brush-cursor').style.display = 'block';
            });
        }

        function closeExport() {
            document.getElementById('export-modal').style.display = 'none';
        }

        function downloadPNG() {
            if(!currentCanvasDataURL) return;
            const link = document.createElement('a');
            link.download = `tree-viz-${new Date().getTime()}.png`;
            link.href = currentCanvasDataURL;
            link.click();
        }

        function downloadPDF() {
            if(!currentCanvasDataURL) return;
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [window.innerWidth, window.innerHeight]
            });
            pdf.addImage(currentCanvasDataURL, 'PNG', 0, 0, window.innerWidth, window.innerHeight);
            pdf.save(`tree-viz-${new Date().getTime()}.pdf`);
        }

        function toggleTheme() {
            const html = document.documentElement;
            html.setAttribute('data-theme', html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
        }

        let nodeIdCounter = 0; 
        let treeMode = 'BST'; 

        function setMode(mode) {
            treeMode = mode;
            document.querySelectorAll('.mode-option').forEach(el => el.classList.remove('active'));
            if(mode === 'BST') document.getElementById('mode-bst').classList.add('active');
            if(mode === 'AVL') document.getElementById('mode-avl').classList.add('active');
            if(mode === 'RBT') document.getElementById('mode-rbt').classList.add('active');
            if(mode === 'BTREE') document.getElementById('mode-btree').classList.add('active');
            document.getElementById('order-input-container').style.display = (mode === 'BTREE') ? 'flex' : 'none';
            initTree();
        }

        class Node {
            constructor(val) {
                this.id = nodeIdCounter++; this.value = val;
                this.left = null; this.right = null;
                this.height = 1; this.x = 0; this.y = 0;
                this.color = 'RED'; 
                this.parent = null; 
            }
        }

        // --- FIXED B-TREE LOGIC (NO EMPTY BOXES) ---
        class BTreeNode {
            constructor(leaf = true) {
                this.id = nodeIdCounter++;
                this.leaf = leaf;
                this.keys = [];
                this.children = [];
                this.x = 0; this.y = 0; this.width = 0; this.subTreeWidth = 0;
            }
        }

        class BTreeLogic {
            constructor(order) {
                this.order = order;
                // Max keys = order - 1
                this.root = null;
            }
            compare(a, b) {
                const numA = parseFloat(a), numB = parseFloat(b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return String(a).localeCompare(String(b));
            }
            insert(k) {
                if (!this.root) {
                    this.root = new BTreeNode(true);
                    this.root.keys.push(k);
                } else {
                    if (this.root.keys.length === this.order - 1) {
                        let s = new BTreeNode(false);
                        s.children.push(this.root);
                        this.splitChild(s, 0);
                        this.root = s;
                        this.insertNonFull(s, k);
                    } else {
                        this.insertNonFull(this.root, k);
                    }
                }
            }
            insertNonFull(x, k) {
                let i = x.keys.length - 1;
                if (x.leaf) {
                    while (i >= 0 && this.compare(x.keys[i], k) > 0) i--;
                    x.keys.splice(i + 1, 0, k);
                } else {
                    while (i >= 0 && this.compare(x.keys[i], k) > 0) i--;
                    i++;
                    if (x.children[i].keys.length === this.order - 1) {
                        this.splitChild(x, i);
                        if (this.compare(x.keys[i], k) < 0) i++;
                    }
                    this.insertNonFull(x.children[i], k);
                }
            }
            splitChild(x, i) {
                let y = x.children[i];
                let z = new BTreeNode(y.leaf);
                // Median index logic for standard B-Tree
                let midIndex = Math.floor((this.order - 1) / 2);
                
                // Z gets keys after median
                z.keys = y.keys.splice(midIndex + 1);
                
                // Z gets children after median (+1 because children count is keys + 1)
                if (!y.leaf) {
                    z.children = y.children.splice(midIndex + 1);
                }

                // Middle key goes up
                let midKey = y.keys.pop();

                x.children.splice(i + 1, 0, z);
                x.keys.splice(i, 0, midKey);
            }
        }

        class Tree {
            constructor(mode) { this.root = null; this.mode = mode; }
            compare(a, b) {
                const numA = parseFloat(a), numB = parseFloat(b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return String(a).localeCompare(String(b));
            }
            getHeight(N) { return N ? N.height : 0; }
            getBalance(N) { return N ? this.getHeight(N.left) - this.getHeight(N.right) : 0; }
            rightRotate(y) {
                let x = y.left; let T2 = x.right;
                x.right = y; y.left = T2;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                return x;
            }
            leftRotate(x) {
                let y = x.right; let T2 = y.left;
                y.left = x; x.right = T2;
                x.height = Math.max(this.getHeight(x.left), this.getHeight(x.right)) + 1;
                y.height = Math.max(this.getHeight(y.left), this.getHeight(y.right)) + 1;
                return y;
            }
            insert(val) { 
                if (this.mode === 'RBT') { this.insertRBT(val); } 
                else { this.root = this.insertNode(this.root, val); }
            }
            insertNode(node, val) {
                if (!node) return new Node(val);
                if (this.compare(val, node.value) < 0) node.left = this.insertNode(node.left, val);
                else node.right = this.insertNode(node.right, val);
                if (this.mode !== 'AVL') return node;
                node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
                let balance = this.getBalance(node);
                if (balance > 1 && this.compare(val, node.left.value) < 0) return this.rightRotate(node);
                if (balance < -1 && this.compare(val, node.right.value) >= 0) return this.leftRotate(node);
                if (balance > 1 && this.compare(val, node.left.value) > 0) { node.left = this.leftRotate(node.left); return this.rightRotate(node); }
                if (balance < -1 && this.compare(val, node.right.value) < 0) { node.right = this.rightRotate(node.right); return this.leftRotate(node); }
                return node;
            }
            insertRBT(val) {
                let newNode = new Node(val);
                let y = null; let x = this.root;
                while (x !== null) { y = x; if (this.compare(newNode.value, x.value) < 0) x = x.left; else x = x.right; }
                newNode.parent = y;
                if (y === null) this.root = newNode; else if (this.compare(newNode.value, y.value) < 0) y.left = newNode; else y.right = newNode;
                newNode.left = null; newNode.right = null; newNode.color = 'RED'; 
                this.fixInsertRBT(newNode);
            }
            rotateLeftRBT(x) {
                let y = x.right; x.right = y.left;
                if (y.left !== null) y.left.parent = x; y.parent = x.parent;
                if (x.parent === null) this.root = y; else if (x === x.parent.left) x.parent.left = y; else x.parent.right = y;
                y.left = x; x.parent = y;
            }
            rotateRightRBT(y) {
                let x = y.left; y.left = x.right;
                if (x.right !== null) x.right.parent = y; x.parent = y.parent;
                if (y.parent === null) this.root = x; else if (y === y.parent.right) y.parent.right = x; else y.parent.left = x;
                x.right = y; y.parent = x;
            }
            fixInsertRBT(k) {
                while (k.parent && k.parent.color === 'RED') {
                    if (k.parent === k.parent.parent.right) {
                        let u = k.parent.parent.left; 
                        if (u && u.color === 'RED') { u.color = 'BLACK'; k.parent.color = 'BLACK'; k.parent.parent.color = 'RED'; k = k.parent.parent; } 
                        else { if (k === k.parent.left) { k = k.parent; this.rotateRightRBT(k); } k.parent.color = 'BLACK'; k.parent.parent.color = 'RED'; this.rotateLeftRBT(k.parent.parent); }
                    } else {
                        let u = k.parent.parent.right;
                        if (u && u.color === 'RED') { u.color = 'BLACK'; k.parent.color = 'BLACK'; k.parent.parent.color = 'RED'; k = k.parent.parent; } 
                        else { if (k === k.parent.right) { k = k.parent; this.rotateLeftRBT(k); } k.parent.color = 'BLACK'; k.parent.parent.color = 'RED'; this.rotateRightRBT(k.parent.parent); }
                    }
                    if (k === this.root) break;
                }
                this.root.color = 'BLACK';
            }
            getSearchData(val) {
                const pathNodes = []; let leftCount = 0; let rightCount = 0; let current = this.root;
                while(current) {
                    pathNodes.push(current);
                    const diff = this.compare(val, current.value);
                    if (diff === 0) return { pathNodes, leftCount, rightCount, found: true }; 
                    if (diff < 0) { current = current.left; leftCount++; } else { current = current.right; rightCount++; }
                }
                return { pathNodes, leftCount, rightCount, found: false };
            }
            delete(val) {
                if (this.mode !== 'BST') { alert("Delete is currently only supported in standard BST mode."); return; }
                this.root = this.deleteNode(this.root, val);
            }
            deleteNode(root, val) {
                if (!root) return root;
                const diff = this.compare(val, root.value);
                if (diff < 0) root.left = this.deleteNode(root.left, val);
                else if (diff > 0) root.right = this.deleteNode(root.right, val);
                else {
                    if (!root.left) return root.right;
                    if (!root.right) return root.left;
                    root.value = this.minValue(root.right);
                    root.right = this.deleteNode(root.right, root.value);
                }
                return root;
            }
            minValue(node) {
                let minv = node.value; while (node.left) { minv = node.left.value; node = node.left; } return minv;
            }
        }

        const NODE_R = 18, X_GAP = 30, Y_GAP = 70;   
        let treeInstance = null;
        let bTreeInstance = null;
        let currentTreeData = [];
        let viewState = { scale: 1, pX: 0, pY: 0, isDragging: false, startX: 0, startY: 0 };
        const container = document.getElementById('canvas-container');
        const viewport = document.getElementById('viewport');
        const searchBtn = document.getElementById('btn-search');
        const deleteBtn = document.getElementById('btn-delete');
        const pathDisplay = document.getElementById('path-val');

        function initTree(data = null) {
            nodeIdCounter = 0; pathDisplay.innerHTML = ""; 
            let final;
            if(data) { final = data; } else {
                const input = document.getElementById('node-input');
                const raw = input.value.split(',').map(s => s.trim().toUpperCase()).filter(s => s !== "");
                if (!raw.length) return;
                final = raw.map(v => (isNaN(parseFloat(v)) ? v : parseFloat(v)));
            }
            currentTreeData = [...final];
            viewport.innerHTML = ''; 
            searchBtn.disabled = true;
            deleteBtn.disabled = (treeMode !== 'BST'); 

            if (treeMode === 'BTREE') {
                let order = parseInt(document.getElementById('order-input').value) || 3;
                bTreeInstance = new BTreeLogic(order);
                final.forEach(n => bTreeInstance.insert(n));
                if(bTreeInstance.root) {
                    drawBTree(bTreeInstance.root);
                }
            } else {
                treeInstance = new Tree(treeMode);
                final.forEach(n => treeInstance.insert(n));
                if (treeInstance.root) {
                    let xCounter = 0;
                    const calcPos = (node, depth) => {
                        if (!node) return;
                        calcPos(node.left, depth + 1);
                        node.x = xCounter * X_GAP; node.y = depth * Y_GAP;
                        xCounter++;
                        calcPos(node.right, depth + 1);
                    };
                    calcPos(treeInstance.root, 0);
                    drawLinks(treeInstance.root);
                    drawNodes(treeInstance.root);
                    let startY = 40;
                    const panel = document.querySelector('.glass-panel');
                    if (panel) { const rect = panel.getBoundingClientRect(); if(rect.bottom > 50) startY = rect.bottom + 50; }
                    smartFit((xCounter) * X_GAP, (getMaxDepth(treeInstance.root) + 1) * Y_GAP, startY);
                    searchBtn.disabled = false;
                } else { deleteBtn.disabled = true; }
            }
        }

        function deleteNode() {
            let inputVal = document.getElementById('search-input').value.trim().toUpperCase();
            if (!inputVal || !treeInstance || treeMode !== 'BST') return;
            let delVal = isNaN(parseFloat(inputVal)) ? inputVal : parseFloat(inputVal);
            treeInstance.delete(delVal);
            const index = currentTreeData.findIndex(v => treeInstance.compare(v, delVal) === 0);
            if (index > -1) { currentTreeData.splice(index, 1); }
            viewport.innerHTML = ''; nodeIdCounter = 0; pathDisplay.innerHTML = "Node Deleted.";
            if (treeInstance.root) {
                 let xCounter = 0;
                 const calcPos = (node, depth) => {
                     if (!node) return;
                     calcPos(node.left, depth + 1);
                     node.x = xCounter * X_GAP; node.y = depth * Y_GAP;
                     node.id = nodeIdCounter++;
                     xCounter++;
                     calcPos(node.right, depth + 1);
                 };
                 calcPos(treeInstance.root, 0);
                 drawLinks(treeInstance.root);
                 drawNodes(treeInstance.root);
            } else { deleteBtn.disabled = true; searchBtn.disabled = true; }
        }

        function drawBTree(root) {
            const CELL_W = 30; const NODE_H = 30; const V_GAP = 80; const H_GAP = 20;
            const calculateWidths = (node) => {
                if (!node) return 0;
                node.width = node.keys.length * CELL_W + 10; 
                if (node.leaf) { node.subTreeWidth = node.width; } else {
                    let childrenWidth = 0;
                    // Count only actual children
                    node.children.forEach((child, i) => { 
                        childrenWidth += calculateWidths(child); 
                        if (i < node.children.length - 1) childrenWidth += H_GAP; 
                    });
                    node.subTreeWidth = Math.max(node.width, childrenWidth);
                }
                return node.subTreeWidth;
            };
            calculateWidths(root);
            const render = (node, x, y) => {
                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.setAttribute("class", "node-group animate-pop");
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", x - node.width/2); rect.setAttribute("y", y - NODE_H/2);
                rect.setAttribute("width", node.width); rect.setAttribute("height", NODE_H);
                rect.setAttribute("rx", 4); rect.setAttribute("class", "btree-node");
                g.appendChild(rect);
                const startX = x - node.width/2 + 5;
                node.keys.forEach((k, i) => {
                    const cellX = startX + i * CELL_W;
                    const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    txt.setAttribute("x", cellX + CELL_W/2); txt.setAttribute("y", y);
                    txt.setAttribute("class", "btree-text"); txt.textContent = k;
                    g.appendChild(txt);
                    if(i < node.keys.length - 1) {
                        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        line.setAttribute("x1", cellX + CELL_W); line.setAttribute("x2", cellX + CELL_W);
                        line.setAttribute("y1", y - NODE_H/2); line.setAttribute("y2", y + NODE_H/2);
                        line.setAttribute("class", "btree-separator"); g.appendChild(line);
                    }
                });
                viewport.appendChild(g);
                if(!node.leaf) {
                    let currentChildX = x - node.subTreeWidth/2;
                    const nextY = y + V_GAP;
                    node.children.forEach((child, i) => {
                        const childX = currentChildX + child.subTreeWidth/2;
                        
                        // Smart slot connection: 
                        // i=0 connects before key0, i=1 connects between key0-key1, etc.
                        const slotX = (x - node.width/2 + 5) + (i * CELL_W); 
                        
                        const link = document.createElementNS("http://www.w3.org/2000/svg", "line");
                        link.setAttribute("x1", slotX); link.setAttribute("y1", y + NODE_H/2);
                        link.setAttribute("x2", childX); link.setAttribute("y2", nextY - NODE_H/2);
                        link.setAttribute("class", "link");
                        viewport.insertBefore(link, viewport.firstChild);
                        render(child, childX, nextY);
                        currentChildX += child.subTreeWidth + H_GAP;
                    });
                }
            };
            let startY = 40;
            const panel = document.querySelector('.glass-panel');
            if(panel) { const r = panel.getBoundingClientRect(); if(r.bottom > 50) startY = r.bottom + 50; }
            render(root, 0, startY + NODE_H/2);
            smartFit(root.subTreeWidth, 500, startY);
        }

        async function searchTree() {
            if (treeMode === 'BTREE') return; 
            if (!treeInstance || !treeInstance.root) return;
            let inputVal = document.getElementById('search-input').value.trim().toUpperCase();
            if (!inputVal) return;
            let searchVal = isNaN(parseFloat(inputVal)) ? inputVal : parseFloat(inputVal);
            resetHighlights();
            pathDisplay.innerHTML = "Searching...";
            const { pathNodes, leftCount, rightCount, found } = treeInstance.getSearchData(searchVal);
            for (let i = 0; i < pathNodes.length; i++) {
                const node = pathNodes[i];
                const svgNode = document.getElementById(`circle-${node.id}`);
                if (svgNode) {
                    if (i === pathNodes.length - 1 && found) svgNode.classList.add('found');
                    else svgNode.classList.add('visited');
                }
                if (i < pathNodes.length - 1) {
                    const nextNode = pathNodes[i+1];
                    const linkId = `link-${node.id}-${nextNode.id}`;
                    const svgLink = document.getElementById(linkId);
                    if (svgLink) {
                        if (treeInstance.compare(nextNode.value, node.value) < 0) svgLink.classList.add('anim-left');
                        else svgLink.classList.add('anim-right');
                    }
                }
                await new Promise(r => setTimeout(r, 400));
            }
            if (found) pathDisplay.innerHTML = `Found! Moves: <span class="count-left">${leftCount} Left</span>, <span class="count-right">${rightCount} Right</span>`;
            else pathDisplay.innerHTML = `Not Found. (Moves: ${leftCount} L, ${rightCount} R)`;
        }

        function handleSearchInput() {
            document.getElementById('search-input').value = document.getElementById('search-input').value.toUpperCase();
            pathDisplay.innerHTML = "";
            resetHighlights();
        }

        function resetHighlights() {
            document.querySelectorAll('.node-circle').forEach(el => el.classList.remove('visited', 'found'));
            document.querySelectorAll('.link').forEach(el => el.classList.remove('anim-left', 'anim-right'));
        }

        function getMaxDepth(node) {
            if (!node) return 0;
            return 1 + Math.max(getMaxDepth(node.left), getMaxDepth(node.right));
        }

        function drawLinks(node) {
            if (!node) return;
            if (node.left) { createLine(node.x, node.y, node.left.x, node.left.y, node.id, node.left.id, "L"); drawLinks(node.left); }
            if (node.right) { createLine(node.x, node.y, node.right.x, node.right.y, node.id, node.right.id, "R"); drawLinks(node.right); }
        }

        function createLine(x1, y1, x2, y2, startId, endId, label) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1); line.setAttribute("y1", y1);
            line.setAttribute("x2", x2); line.setAttribute("y2", y2);
            line.setAttribute("class", "link");
            line.setAttribute("id", `link-${startId}-${endId}`);
            viewport.appendChild(line);
            const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g"); g.style.pointerEvents = "none";
            const bg = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            bg.setAttribute("cx", midX); bg.setAttribute("cy", midY); bg.setAttribute("r", 6); bg.setAttribute("class", "edge-label-bg");
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", midX); text.setAttribute("y", midY); text.setAttribute("dy", "0.5px"); text.setAttribute("class", "edge-label-text");
            text.textContent = label;
            g.appendChild(bg); g.appendChild(text); viewport.appendChild(g);
        }

        function drawNodes(node) {
            if (!node) return;
            createNode(node);
            drawNodes(node.left); drawNodes(node.right);
        }

        function createNode(node) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("class", "node-group animate-pop");
            if (treeMode === 'RBT') g.classList.add('rbt-mode');
            g.style.animationDelay = `${node.y/Y_GAP * 50}ms`;
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", node.x); circle.setAttribute("cy", node.y); circle.setAttribute("r", NODE_R);
            circle.setAttribute("class", "node-circle"); 
            circle.setAttribute("id", `circle-${node.id}`);
            if (treeMode === 'RBT') {
                if (node.color === 'RED') circle.classList.add('red');
                else circle.classList.add('black');
            }
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", node.x); text.setAttribute("y", node.y); text.setAttribute("class", "node-text"); 
            text.textContent = node.value;
            g.appendChild(circle); g.appendChild(text); viewport.appendChild(g);
        }

        function smartFit(treeW, treeH, offsetY = 40) {
            const w = container.clientWidth, h = container.clientHeight;
            const padding = 60; 
            const scale = Math.min((w - padding) / Math.max(treeW, 100), (h - padding) / Math.max(treeH, 100), 1.2);
            viewState.scale = Math.max(scale, 0.2);
            viewState.pX = (w - treeW * viewState.scale) / 2;
            viewState.pY = Math.max((h - treeH * viewState.scale) / 2, offsetY); 
            updateTransform();
        }

        function updateTransform() { 
            viewport.setAttribute("transform", `translate(${viewState.pX}, ${viewState.pY}) scale(${viewState.scale})`); 
            renderDrawings();
        }
        
        function getPointerPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        window.oncontextmenu = (e) => e.preventDefault();
        const wrapper = document.getElementById('container-wrapper');

        wrapper.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = wrapper.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldX = (mouseX - viewState.pX) / viewState.scale;
            const worldY = (mouseY - viewState.pY) / viewState.scale;
            const zoomSensitivity = 0.001;
            let newScale = viewState.scale + (e.deltaY * -zoomSensitivity * viewState.scale);
            newScale = Math.max(0.05, Math.min(newScale, 10));
            viewState.pX = mouseX - worldX * newScale;
            viewState.pY = mouseY - worldY * newScale;
            viewState.scale = newScale;
            updateTransform();
        }, { passive: false });

        function startPan(e) {
            const pos = getPointerPos(e);
            const isMouse = !e.touches;
            const isRightOrMiddle = isMouse && (e.button === 1 || e.button === 2);
            const isHandTool = currentTool === 'hand' && (isMouse ? e.button === 0 : true);

            if (isRightOrMiddle || isHandTool) {
                viewState.isDragging = true;
                viewState.startX = pos.x - viewState.pX;
                viewState.startY = pos.y - viewState.pY;
                wrapper.style.cursor = "grabbing";
            }
        }

        function movePan(e) {
            if (viewState.isDragging) {
                e.preventDefault();
                const pos = getPointerPos(e);
                viewState.pX = pos.x - viewState.startX;
                viewState.pY = pos.y - viewState.startY;
                updateTransform();
            }
        }

        function endPan() {
            viewState.isDragging = false;
            if(currentTool === 'hand') wrapper.style.cursor = "grab";
            else wrapper.style.cursor = "default";
        }

        wrapper.addEventListener('mousedown', startPan);
        window.addEventListener('mousemove', movePan);
        window.addEventListener('mouseup', endPan);
        wrapper.addEventListener('touchstart', startPan, {passive: false});
        window.addEventListener('touchmove', movePan, {passive: false});
        window.addEventListener('touchend', endPan);

        const inputNode = document.getElementById('node-input');
        function autoResize() {
            this.style.height = 'auto'; 
            const newHeight = Math.max(36, this.scrollHeight);
            this.style.height = newHeight + 'px'; 
        }
        inputNode.addEventListener('input', autoResize);
        inputNode.addEventListener('keypress', function(e) { if(e.key === "Enter") { e.preventDefault(); initTree(); } });
        document.getElementById('search-input').addEventListener('keypress', (e) => { if(e.key === "Enter" && !searchBtn.disabled) searchTree(); });
        
        // --- ADVANCED DRAWING ENGINE ---
        const drawCanvas = document.getElementById('draw-layer');
        const ctx = drawCanvas.getContext('2d');
        const colorPicker = document.getElementById('draw-color');
        const sizeDragger = document.getElementById('size-dragger');
        const sizeValSpan = document.getElementById('size-val');
        const miniSlider = document.getElementById('mini-slider');
        const cursorDiv = document.getElementById('brush-cursor');
        
        let drawings = []; 
        let history = []; 
        let redoStack = []; 
        let currentStroke = null;
        let isDrawing = false;
        let currentTool = 'hand'; 
        
        let toolSettings = {
            hand: { size: 0 },
            pen: { size: 5 },
            marker: { size: 25 },
            eraser: { size: 20 },
            box: { size: 3 },
            circle: { size: 3 },
            arrow: { size: 3 }
        };

        // --- RAF LOOP ---
        let isDirty = true; 
        function loop() {
            if (isDirty) {
                renderDrawings();
                isDirty = false;
            }
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop); 

        function resizeCanvas() {
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;
            isDirty = true;
        }
        window.addEventListener('resize', resizeCanvas);

        function updateToolUI() {
            const s = toolSettings[currentTool].size;
            sizeValSpan.textContent = s;
            miniSlider.value = s;
            const isHand = currentTool === 'hand';
            sizeDragger.style.opacity = isHand ? '0.3' : '1';
            sizeDragger.style.pointerEvents = isHand ? 'none' : 'auto';
            miniSlider.style.opacity = isHand ? '0.3' : '1';
            miniSlider.disabled = isHand;
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const btn = document.querySelector(`.tool-btn[onclick="setTool('${tool}')"]`);
            if(btn) btn.classList.add('active');
            updateToolUI();
            if (tool === 'hand') {
                drawCanvas.style.pointerEvents = 'none'; 
                cursorDiv.style.display = 'none';
                wrapper.style.cursor = 'grab';
            } else {
                drawCanvas.style.pointerEvents = 'auto'; 
                wrapper.style.cursor = 'default';
                if(['pen','marker','eraser'].includes(tool)) {
                    cursorDiv.style.display = 'block';
                    drawCanvas.style.cursor = 'none';
                } else {
                    cursorDiv.style.display = 'none';
                    drawCanvas.style.cursor = 'crosshair';
                }
            }
        }

        function saveState() {
            history.push(JSON.parse(JSON.stringify(drawings)));
            redoStack = []; 
            if (history.length > 50) history.shift();
        }
        function undo() { if (history.length === 0) return; redoStack.push(JSON.parse(JSON.stringify(drawings))); drawings = history.pop(); isDirty = true; }
        function redo() { if (redoStack.length === 0) return; history.push(JSON.parse(JSON.stringify(drawings))); drawings = redoStack.pop(); isDirty = true; }
        function clearDrawings() { saveState(); drawings = []; isDirty = true; }
        
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); if(e.shiftKey) redo(); else undo(); } 
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });

        function updateSize(newSize) {
            newSize = Math.max(1, Math.min(newSize, 100));
            toolSettings[currentTool].size = newSize;
            sizeValSpan.textContent = newSize;
            miniSlider.value = newSize;
            if(cursorDiv.style.display !== 'none') {
                cursorDiv.style.width = (newSize * viewState.scale) + 'px';
                cursorDiv.style.height = (newSize * viewState.scale) + 'px';
            }
        }
        miniSlider.addEventListener('input', (e) => { updateSize(parseInt(e.target.value)); });

        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartVal = 0;

        function startResize(e) {
            isResizing = true;
            const pos = getPointerPos(e);
            resizeStartX = pos.x;
            resizeStartVal = toolSettings[currentTool].size;
            sizeDragger.classList.add('dragging');
            document.body.style.cursor = 'ew-resize';
        }
        function moveResize(e) {
            if(isResizing) {
                e.preventDefault();
                const pos = getPointerPos(e);
                const delta = pos.x - resizeStartX;
                let newSize = resizeStartVal + Math.floor(delta / 2);
                updateSize(newSize);
            }
        }
        function endResize() {
            if(isResizing) {
                isResizing = false;
                sizeDragger.classList.remove('dragging');
                document.body.style.cursor = 'default';
            }
        }
        sizeDragger.addEventListener('mousedown', startResize);
        window.addEventListener('mousemove', moveResize);
        window.addEventListener('mouseup', endResize);
        sizeDragger.addEventListener('touchstart', startResize, {passive: false});
        window.addEventListener('touchmove', moveResize, {passive: false});
        window.addEventListener('touchend', endResize);

        const toolbar = document.getElementById('toolbar');
        const handle = document.getElementById('toolbar-drag');
        let isDraggingToolbar = false;
        let tbOffsetX, tbOffsetY; 

        function startTbDrag(e) {
            e.preventDefault();
            isDraggingToolbar = true;
            const pos = getPointerPos(e);
            
            const layer = document.querySelector('.toolbar-layer');
            const rect = layer.getBoundingClientRect();
            
            layer.classList.remove('pinned-mobile');
            layer.style.left = rect.left + 'px';
            layer.style.top = rect.top + 'px';
            layer.style.right = 'auto';
            layer.style.bottom = 'auto';
            layer.style.transform = 'none'; 
            
            tbOffsetX = pos.x - rect.left;
            tbOffsetY = pos.y - rect.top;
            
            document.body.style.cursor = 'grabbing';
            handle.style.cursor = 'grabbing';
        }

        function moveTbDrag(e) {
            if(isDraggingToolbar) {
                e.preventDefault();
                const pos = getPointerPos(e);
                const layer = document.querySelector('.toolbar-layer');
                layer.style.left = (pos.x - tbOffsetX) + 'px';
                layer.style.top = (pos.y - tbOffsetY) + 'px';
            }
        }
        function endTbDrag() {
            if(isDraggingToolbar) {
                isDraggingToolbar = false;
                document.body.style.cursor = 'default';
                handle.style.cursor = 'grab';
            }
        }
        handle.addEventListener('mousedown', startTbDrag);
        window.addEventListener('mousemove', moveTbDrag);
        window.addEventListener('mouseup', endTbDrag);
        handle.addEventListener('touchstart', startTbDrag, {passive: false});
        window.addEventListener('touchmove', moveTbDrag, {passive: false});
        window.addEventListener('touchend', endTbDrag);

        function renderDrawings() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            ctx.save();
            ctx.translate(viewState.pX, viewState.pY);
            ctx.scale(viewState.scale, viewState.scale);
            ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = 'source-over';

            const drawItem = (d) => {
                ctx.beginPath(); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                if (d.type === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.globalAlpha = 1.0; ctx.strokeStyle = "rgba(0,0,0,1)"; ctx.lineWidth = d.size;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = d.color; ctx.lineWidth = d.size;
                    ctx.globalAlpha = d.type === 'marker' ? 0.15 : 1.0;
                }

                if (['pen','marker','eraser'].includes(d.type)) {
                    if(d.points.length < 2) return;
                    ctx.moveTo(d.points[0].x, d.points[0].y);
                    for(let i=1; i<d.points.length; i++) ctx.lineTo(d.points[i].x, d.points[i].y);
                    ctx.stroke();
                }
                else if (d.type === 'box') {
                    ctx.rect(d.x, d.y, d.w, d.h);
                    ctx.stroke();
                }
                else if (d.type === 'circle') {
                    let cx = d.x + d.w/2;
                    let cy = d.y + d.h/2;
                    let rx = Math.abs(d.w/2);
                    let ry = Math.abs(d.h/2);
                    ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                else if (d.type === 'arrow') {
                    drawArrowInContext(ctx, d.x1, d.y1, d.x2, d.y2);
                }
                ctx.globalAlpha = 1.0; ctx.globalCompositeOperation = 'source-over';
            };
            drawings.forEach(drawItem);
            if(currentStroke) drawItem(currentStroke);
            ctx.restore();
        }

        function drawArrowInContext(ctx, x1, y1, x2, y2) {
            const headlen = 15; 
            const dx = x2 - x1; const dy = y2 - y1; const angle = Math.atan2(dy, dx);
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function toWorld(x, y) { return { x: (x - viewState.pX) / viewState.scale, y: (y - viewState.pY) / viewState.scale }; }

        function startDraw(e) {
            if(!e.touches && e.button !== 0) return;
            if(currentTool === 'hand') return;

            e.preventDefault(); 
            saveState();
            isDrawing = true;
            const pos = getPointerPos(e);
            const wPos = toWorld(pos.x, pos.y);
            let size = toolSettings[currentTool].size;

            if(['pen','marker','eraser'].includes(currentTool)) {
                currentStroke = { type: currentTool, color: colorPicker.value, size: size, points: [{x: wPos.x, y: wPos.y}] };
            } else {
                currentStroke = {
                    type: currentTool, color: colorPicker.value, size: size,
                    startX: wPos.x, startY: wPos.y,
                    x: wPos.x, y: wPos.y, w: 0, h: 0, 
                    x1: wPos.x, y1: wPos.y, x2: wPos.x, y2: wPos.y 
                };
            }
            isDirty = true;
        }

        function moveDraw(e) {
            const pos = getPointerPos(e);
            if(cursorDiv.style.display !== 'none') {
                cursorDiv.style.left = pos.x + 'px';
                cursorDiv.style.top = pos.y + 'px';
                let size = toolSettings[currentTool].size;
                cursorDiv.style.width = (size * viewState.scale) + 'px';
                cursorDiv.style.height = (size * viewState.scale) + 'px';
            }

            if (!isDrawing || !currentStroke) return;
            e.preventDefault();

            const wPos = toWorld(pos.x, pos.y);

            if(['pen','marker','eraser'].includes(currentTool)) {
                currentStroke.points.push({x: wPos.x, y: wPos.y});
            } 
            else if (currentTool === 'box' || currentTool === 'circle') {
                currentStroke.x = currentStroke.startX;
                currentStroke.y = currentStroke.startY;
                currentStroke.w = wPos.x - currentStroke.startX;
                currentStroke.h = wPos.y - currentStroke.startY;
            }
            else if (currentTool === 'arrow') {
                currentStroke.x2 = wPos.x;
                currentStroke.y2 = wPos.y;
            }
            isDirty = true;
        }

        function endDraw() {
            if(isDrawing && currentStroke) {
                drawings.push(currentStroke);
                currentStroke = null;
                isDrawing = false;
                isDirty = true;
            }
        }

        drawCanvas.addEventListener('mousedown', startDraw);
        window.addEventListener('mousemove', moveDraw);
        window.addEventListener('mouseup', endDraw);
        drawCanvas.addEventListener('touchstart', startDraw, {passive: false});
        window.addEventListener('touchmove', moveDraw, {passive: false});
        window.addEventListener('touchend', endDraw);

        window.onload = () => {
            autoResize.call(inputNode);
            resizeCanvas();
            setTimeout(() => initTree(), 50);
            updateToolUI(); 
        };
    </script>
</body>
</html>
